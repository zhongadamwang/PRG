---
name: plan-buildschedule
description: Generate project schedules with task dependencies, critical path analysis, resource constraints, and milestone planning in markdown format with Gantt representations and schedule optimization capabilities.
license: MIT
---

# Plan.BuildSchedule Skill

## Intent
Generate comprehensive project schedules based on task breakdowns and effort estimates, incorporating dependency management, critical path analysis, resource constraints, and milestone planning to create optimized project timelines with clear deliverable checkpoints and markdown-based Gantt chart visualizations.

## Inputs
- **Source**: `projects/[project-name]/artifacts/Analysis/task-breakdown.json` (generated by plan-derivetasks skill)
- **Source**: `projects/[project-name]/artifacts/Analysis/effort-estimates.json` (generated by plan-estimateeffort skill)
- **Optional**: Resource allocation constraints and team availability data
- **Optional**: Project deadlines and milestone requirements from project charter
- **Format**: Structured task and estimation data with dependencies and effort calculations

## Outputs

**Files Generated:**
- `projects/[project-name]/artifacts/Analysis/project-schedule.json` - Structured schedule data for programmatic use
- `projects/[project-name]/artifacts/Analysis/project-schedule.md` - Human-readable schedule with Gantt representation
- `projects/[project-name]/artifacts/Analysis/critical-path-analysis.md` - Critical path analysis and schedule optimization report
- `projects/[project-name]/artifacts/Analysis/milestone-plan.md` - Milestone definitions and delivery checkpoints

### JSON Structure (`project-schedule.json`)
```json
{
  "project_id": "string",
  "generated_at": "ISO_timestamp",
  "schedule_version": "string",
  "project_duration": {
    "start_date": "ISO_date",
    "end_date": "ISO_date",
    "total_duration_days": 0.0,
    "working_days": 0.0,
    "buffer_days": 0.0
  },
  "critical_path": {
    "duration_days": 0.0,
    "tasks": ["task_id_list"],
    "slack_analysis": {
      "total_slack": 0.0,
      "free_slack": 0.0,
      "critical_tasks": ["task_id_list"]
    }
  },
  "resource_allocation": {
    "total_effort_days": 0.0,
    "peak_resource_demand": 0.0,
    "resource_leveling_applied": true,
    "team_assignments": [
      {
        "resource_id": "string",
        "resource_type": "developer|designer|tester|analyst",
        "allocation_percentage": 0.0,
        "assigned_tasks": ["task_id_list"],
        "workload_distribution": {
          "peak_utilization": 0.0,
          "average_utilization": 0.0,
          "utilization_by_week": [0.0]
        }
      }
    ]
  },
  "milestones": [
    {
      "milestone_id": "string",
      "name": "string",
      "description": "string",
      "target_date": "ISO_date",
      "milestone_type": "phase_completion|delivery|review|approval",
      "dependencies": ["milestone_id_list"],
      "deliverables": ["string_list"],
      "success_criteria": ["string_list"],
      "stakeholders": ["string_list"],
      "risk_assessment": {
        "probability_on_time": 0.0,
        "risk_factors": ["string_list"],
        "mitigation_strategies": ["string_list"]
      }
    }
  ],
  "schedule_tasks": [
    {
      "task_id": "string",
      "title": "string",
      "scheduled_start": "ISO_date",
      "scheduled_end": "ISO_date",
      "duration_days": 0.0,
      "actual_effort_days": 0.0,
      "dependencies": [
        {
          "predecessor_id": "string",
          "dependency_type": "finish_to_start|start_to_start|finish_to_finish|start_to_finish",
          "lag_days": 0.0
        }
      ],
      "resource_assignments": [
        {
          "resource_id": "string",
          "allocation_percentage": 0.0,
          "scheduled_effort_days": 0.0
        }
      ],
      "schedule_flexibility": {
        "early_start": "ISO_date",
        "early_finish": "ISO_date",
        "late_start": "ISO_date",
        "late_finish": "ISO_date",
        "total_slack_days": 0.0,
        "free_slack_days": 0.0,
        "is_critical": true
      },
      "milestone_deliverable": "milestone_id_or_null"
    }
  ],
  "schedule_optimization": {
    "optimization_applied": ["resource_leveling", "fast_tracking", "crashing"],
    "baseline_duration": 0.0,
    "optimized_duration": 0.0,
    "time_savings": 0.0,
    "cost_impact": "string",
    "risk_impact": "string"
  },
  "what_if_scenarios": [
    {
      "scenario_name": "string",
      "scenario_type": "best_case|worst_case|resource_constrained|accelerated",
      "assumptions": ["string_list"],
      "duration_impact": 0.0,
      "resource_impact": 0.0,
      "risk_assessment": "string"
    }
  ]
}
```

### Markdown Structure (`project-schedule.md`)
```markdown
# Project Schedule

## Schedule Overview
- **Project**: [project_name]
- **Duration**: [total_days] days ([start_date] to [end_date])
- **Critical Path Length**: [critical_path_days] days
- **Total Effort**: [total_effort] person-days
- **Schedule Buffer**: [buffer_percentage]%

## Gantt Chart (Text Representation)

```
Task                    | Start     | End       | Duration |████████████████████████████
T001 - Setup Auth       | 2026-02-21| 2026-02-23|  2.0d    |██████░░░░░░░░░░░░░░░░░░░░░░
T002 - User Registration| 2026-02-24| 2026-02-25|  1.5d    |      ████░░░░░░░░░░░░░░░░░░
T003 - Profile UI       | 2026-02-21| 2026-02-21|  1.0d    |██░░░░░░░░░░░░░░░░░░░░░░░░░░
T004 - Profile API      | 2026-02-26| 2026-02-27|  1.5d    |          ████░░░░░░░░░░░░░░
T005 - Data Viz         | 2026-02-21| 2026-02-25|  3.0d    |████████████░░░░░░░░░░░░░░
T006 - Integration Test | 2026-02-28| 2026-03-02|  2.0d    |              ██████░░░░░░
```

## Critical Path Analysis

### Critical Tasks
[List of critical path tasks with zero slack]

### Schedule Risks
[Identified scheduling risks and mitigation strategies]

### Optimization Opportunities
[Potential schedule improvements and trade-offs]

## Resource Allocation

### Team Assignments
[Resource allocation by person/role with utilization levels]

### Workload Distribution
[Peak utilization periods and resource leveling recommendations]

## Milestone Schedule

### Major Deliverables
[Timeline of key milestones and delivery checkpoints]

### Stakeholder Reviews
[Scheduled review points and approval gates]
```

## Algorithm

### 1. Schedule Generation Core Algorithm

```python
def generate_project_schedule(task_breakdown, effort_estimates, constraints=None):
    """
    Generate project schedule using Critical Path Method (CPM)
    """
    # Initialize schedule parameters
    schedule = ProjectSchedule()
    
    # Process task dependencies and create network
    task_network = build_dependency_network(task_breakdown['tasks'])
    
    # Apply effort estimates to tasks
    estimated_tasks = apply_effort_estimates(task_network, effort_estimates)
    
    # Perform forward pass (early start/finish calculations)
    early_schedule = calculate_early_times(estimated_tasks)
    
    # Perform backward pass (late start/finish calculations) 
    late_schedule = calculate_late_times(early_schedule)
    
    # Identify critical path and calculate slack
    critical_path = identify_critical_path(late_schedule)
    
    # Apply resource constraints and leveling
    if constraints and constraints.get('resource_limits'):
        leveled_schedule = apply_resource_leveling(late_schedule, constraints)
    else:
        leveled_schedule = late_schedule
    
    # Generate milestone deadlines
    milestones = generate_milestone_schedule(leveled_schedule, task_breakdown)
    
    return {
        'schedule': leveled_schedule,
        'critical_path': critical_path,
        'milestones': milestones
    }
```

### 2. Critical Path Method (CPM) Implementation

#### Forward Pass Calculation
```python
def calculate_early_times(tasks):
    """
    Calculate Early Start (ES) and Early Finish (EF) for all tasks
    """
    # Topological sort to process tasks in dependency order
    sorted_tasks = topological_sort(tasks)
    
    for task in sorted_tasks:
        if not task.predecessors:
            # Tasks with no dependencies start at project start
            task.early_start = project_start_date
        else:
            # ES = max(EF of all predecessors + lag)
            predecessor_finishes = []
            for pred in task.predecessors:
                finish_time = pred.early_finish + pred.lag_to(task)
                predecessor_finishes.append(finish_time)
            task.early_start = max(predecessor_finishes)
        
        # EF = ES + Duration
        task.early_finish = task.early_start + task.duration
    
    return tasks
```

#### Backward Pass Calculation
```python
def calculate_late_times(tasks):
    """
    Calculate Late Start (LS) and Late Finish (LF) for all tasks
    """
    # Process tasks in reverse dependency order
    sorted_tasks = reverse_topological_sort(tasks)
    
    # Set project end date from latest early finish
    project_end = max(task.early_finish for task in tasks)
    
    for task in sorted_tasks:
        if not task.successors:
            # Tasks with no successors finish at project end
            task.late_finish = project_end
        else:
            # LF = min(LS of all successors - lag)
            successor_starts = []
            for succ in task.successors:
                start_time = succ.late_start - task.lag_to(succ)
                successor_starts.append(start_time)
            task.late_finish = min(successor_starts)
        
        # LS = LF - Duration
        task.late_start = task.late_finish - task.duration
        
        # Calculate slack
        task.total_slack = task.late_start - task.early_start
        task.free_slack = min(succ.early_start for succ in task.successors) - task.early_finish
    
    return tasks
```

### 3. Resource Leveling and Allocation

```python
def apply_resource_leveling(schedule, resource_constraints):
    """
    Level resources to smooth workload peaks and respect constraints
    """
    leveled_schedule = copy.deepcopy(schedule)
    
    # Identify resource overallocations by time period
    resource_profile = build_resource_profile(schedule)
    overallocations = identify_overallocations(resource_profile, resource_constraints)
    
    for overallocation in overallocations:
        # Find tasks that can be delayed (non-critical with slack)
        delayable_tasks = find_delayable_tasks(overallocation.period, schedule)
        
        # Sort by priority (least impactful to delay first)
        prioritized_tasks = sort_by_delay_priority(delayable_tasks)
        
        for task in prioritized_tasks:
            if overallocation.resolved():
                break
                
            # Delay task within its slack allowance
            max_delay = min(task.total_slack, overallocation.excess_demand)
            task.scheduled_start += max_delay
            task.scheduled_finish += max_delay
            
            # Update resource allocation
            update_resource_profile(resource_profile, task, max_delay)
            overallocation.reduce_excess(task.resource_demand * max_delay)
    
    return leveled_schedule
```

### 4. Milestone Planning Algorithm

```python
def generate_milestone_schedule(schedule, task_breakdown):
    """
    Generate milestone schedule based on task completion and deliverables
    """
    milestones = []
    
    # Identify natural milestone candidates
    milestone_candidates = identify_milestone_tasks(schedule, task_breakdown)
    
    for candidate in milestone_candidates:
        milestone = Milestone(
            name=generate_milestone_name(candidate),
            target_date=candidate.scheduled_finish,
            deliverables=candidate.deliverables,
            dependencies=find_milestone_dependencies(candidate, milestones)
        )
        
        # Assess milestone risk based on critical path proximity
        milestone.risk_assessment = assess_milestone_risk(candidate, schedule)
        
        milestones.append(milestone)
    
    # Add phase completion milestones
    for phase in task_breakdown['phases']:
        phase_tasks = get_phase_tasks(phase, schedule)
        phase_completion = max(task.scheduled_finish for task in phase_tasks)
        
        milestones.append(Milestone(
            name=f"{phase['phase_name']} Completion",
            target_date=phase_completion,
            milestone_type='phase_completion',
            deliverables=aggregate_phase_deliverables(phase_tasks)
        ))
    
    return sort_milestones_chronologically(milestones)
```

### 5. Schedule Optimization Strategies

#### Fast Tracking
- Identify tasks that can run in parallel instead of sequence
- Assess risk of increased coordination overhead
- Calculate time savings vs. risk increase

#### Crashing
- Identify tasks where additional resources can reduce duration
- Calculate cost-benefit of resource increases
- Optimize resource allocation for maximum impact

#### Buffer Management
- Add project buffers for uncertainty management
- Distribute buffer time across critical and near-critical paths
- Monitor buffer consumption during execution

## Integration Workflow

### 1. Input Validation and Processing
```python
def validate_inputs(task_breakdown, effort_estimates):
    """
    Ensure input data is consistent and complete
    """
    # Verify all tasks in breakdown have effort estimates
    missing_estimates = find_missing_estimates(task_breakdown, effort_estimates)
    if missing_estimates:
        raise ValueError(f"Missing effort estimates for tasks: {missing_estimates}")
    
    # Check for circular dependencies
    cycles = detect_dependency_cycles(task_breakdown['tasks'])
    if cycles:
        raise ValueError(f"Circular dependencies detected: {cycles}")
    
    # Validate dependency references
    validate_dependency_references(task_breakdown['tasks'])
    
    return True
```

### 2. Schedule Generation Pipeline
```markdown
Task Breakdown + Effort Estimates → Dependency Network → CPM Analysis → Resource Leveling → Milestone Planning → Schedule Output
```

### 3. Output Generation
- Generate structured JSON for integration with project management tools
- Create human-readable markdown with Gantt charts 
- Produce critical path analysis reports
- Generate milestone tracking documents

### 4. Schedule Validation
- Verify schedule feasibility within project constraints
- Check resource allocation doesn't exceed availability
- Validate milestone dates align with business requirements
- Ensure critical path optimization is effective

## Usage Examples

### Example 1: Software Development Project

**Input Tasks:**
- Authentication system (2.0 days)
- User profile features (3.0 days)
- Data visualization (4.0 days)
- Testing and integration (2.5 days)

**Generated Schedule:**
```
Critical Path: Auth → Profile → Testing (7.5 days)
Parallel Track: Data Visualization (4.0 days)
Project Duration: 7.5 days
Resource Utilization: 95% average, 120% peak (requires leveling)

Milestones:
- M1: Authentication Complete (Day 2)
- M2: Core Features Ready (Day 5) 
- M3: Integration Testing Complete (Day 7.5)
```

### Example 2: Resource-Constrained Environment

**Constraints:**
- 2 developers maximum
- 1 senior developer (can work on any task)
- 1 junior developer (limited task types)

**Optimization Applied:**
- Resource leveling extends timeline by 15%
- Task sequencing prevents resource overallocation
- Junior developer tasks scheduled during senior developer's complex work

### Example 3: Accelerated Schedule

**Requirements:**
- 50% timeline reduction
- Additional resources available
- Higher risk tolerance

**Fast Tracking:**
- Parallel development streams identified
- Integration testing overlapped with development
- Daily integration builds implemented
- Timeline reduced by 40% with managed risk increase

## Error Handling

### Input Validation Errors
- **Missing Dependencies**: Generate warnings and suggest dependency analysis
- **Circular Dependencies**: Identify cycles and provide resolution recommendations
- **Resource Conflicts**: Flag overallocations and suggest leveling strategies

### Scheduling Conflicts
- **Impossible Deadlines**: Flag unrealistic constraints and provide alternatives
- **Resource Overallocation**: Apply automatic leveling or flag for manual resolution
- **Critical Path Risks**: Highlight schedule vulnerabilities and suggest mitigation

### Recovery Strategies
- Provide multiple schedule scenarios (optimistic, realistic, pessimistic)
- Generate alternative resource allocation strategies
- Offer schedule compression recommendations with risk assessments

## Success Metrics

### Schedule Quality Metrics
- **Schedule Efficiency**: Critical path optimization ratio
- **Resource Utilization**: Average and peak resource allocation balance
- **Buffer Adequacy**: Risk-adjusted buffer allocation assessment

### Milestone Metrics
- **Milestone Achievability**: Risk-adjusted probability of on-time delivery
- **Deliverable Completeness**: Coverage of project requirements by milestones
- **Stakeholder Alignment**: Milestone timing vs. business needs alignment

### Optimization Metrics
- **Time Savings**: Baseline vs. optimized schedule duration
- **Resource Smoothing**: Peak vs. average resource demand ratio
- **Risk Management**: Schedule risk mitigation effectiveness

## Customization Points

### Schedule Preferences
- Adjust working hours, holidays, and availability calendars
- Customize resource types and allocation rules
- Define project-specific milestone criteria

### Optimization Parameters
- Configure resource leveling algorithms
- Set schedule compression preferences
- Define acceptable risk-reward trade-offs

### Output Formatting
- Customize Gantt chart visualization parameters
- Modify milestone report templates
- Integrate with specific project management tool formats

## Dependencies

### Required Skills
- **plan-derivetasks**: Provides structured task breakdown with dependencies
- **plan-estimateeffort**: Provides effort estimates for schedule duration calculations

### Optional Skills
- **process-scopemin**: Can provide scope prioritization for milestone definition
- **project-planning-tracking**: Integration with broader project management workflows
- **change-management**: Track schedule impacts of requirement changes

### External Integrations
- Microsoft Project, Primavera P6 for enterprise project management
- Jira, Azure DevOps for agile project tracking
- Calendar systems for team availability and constraint management

## Version History

- **v1.0**: Initial implementation with basic CPM scheduling
- **v1.1**: Added resource leveling and constraint management
- **v1.2**: Enhanced milestone planning and risk assessment
- **v1.3**: Implemented schedule optimization algorithms (fast tracking, crashing)
- **v2.0**: Added what-if scenario analysis and markdown Gantt charts
- **v2.1**: Integrated with project management tool export capabilities