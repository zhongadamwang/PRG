---
name: plan-derivetasks
description: Convert analyzed requirements and goals into actionable development tasks with clear deliverables, acceptance criteria, dependencies, and task categorization for structured project execution.
license: MIT
---

# Plan.DeriveTasks Skill

## Intent
Transform analyzed requirements and extracted goals into a structured task breakdown that provides clear, actionable development work items with defined acceptance criteria, dependencies, and categorization for efficient project execution and tracking.

## Inputs
- **Source**: `projects/[project-name]/artifacts/Analysis/requirements.json` (generated by requirements-ingest skill)
- **Source**: `projects/[project-name]/artifacts/Analysis/goals.json` (generated by goals-extract skill)  
- **Source**: `projects/[project-name]/artifacts/Analysis/w5h-analysis.json` (generated by process-w5h skill)
- **Format**: Structured analysis data with IDs and sections for traceability

## Outputs
**Files Generated:**
- `projects/[project-name]/artifacts/Analysis/task-breakdown.json` - Structured task data for programmatic use
- `projects/[project-name]/artifacts/Analysis/task-breakdown.md` - Human-readable task breakdown structure
- `projects/[project-name]/tasks/` - Individual task files following project task template

### JSON Structure (`task-breakdown.json`)
```json
{
  "project_id": "string",
  "generated_at": "ISO_timestamp",
  "total_tasks": 0,
  "task_categories": [
    "development",
    "design", 
    "testing",
    "documentation",
    "integration",
    "deployment",
    "research"
  ],
  "phases": [
    {
      "phase_id": "string",
      "phase_name": "string", 
      "description": "string",
      "tasks": ["task_id_list"],
      "dependencies": ["phase_id_list"],
      "estimated_duration": "string"
    }
  ],
  "tasks": [
    {
      "task_id": "string",
      "title": "string",
      "description": "string",
      "category": "string",
      "phase": "string",
      "priority": "high|medium|low",
      "estimated_effort": "float (days)",
      "acceptance_criteria": [
        {
          "criterion": "string",
          "testable": true,
          "definition_of_done": "string"
        }
      ],
      "dependencies": [
        {
          "depends_on": "task_id",
          "dependency_type": "prerequisite|blocked_by|related"
        }
      ],
      "source_requirements": ["req_id_list"],
      "source_goals": ["goal_criteria_list"],
      "deliverables": ["string_list"],
      "risk_factors": [
        {
          "risk": "string",
          "mitigation": "string"
        }
      ]
    }
  ],
  "dependency_graph": {
    "critical_path": ["task_id_list"],
    "parallel_tracks": [
      {
        "track_name": "string",
        "tasks": ["task_id_list"]
      }
    ]
  }
}
```

### Markdown Structure (`task-breakdown.md`)
```markdown
# Task Breakdown Structure

## Project Overview
- **Project**: [project_name]
- **Total Tasks**: [count]
- **Estimated Timeline**: [duration]
- **Critical Path Length**: [duration]

## Phase Breakdown

### Phase 1: [Phase Name]
**Description**: [phase description]
**Dependencies**: [list]
**Duration**: [estimate]

#### Tasks
- **T001** - [Task Title] (*category*, *priority*, *effort*)
  - **Description**: [description]
  - **Acceptance Criteria**:
    - [ ] [criterion 1]
    - [ ] [criterion 2]
  - **Dependencies**: [list]
  - **Deliverables**: [list]

## Dependency Analysis

### Critical Path
[ordered list of critical path tasks]

### Parallel Execution Opportunities
- **Track 1**: [parallel tasks]
- **Track 2**: [parallel tasks]

## Risk Assessment
[identified risks and mitigations]
```

## Algorithm

### 1. Requirements Analysis and Categorization

```python
def analyze_requirements(requirements_data, goals_data):
    """
    Categorize requirements by functional area and complexity
    """
    categorized_reqs = {
        'core_functionality': [],
        'integration_points': [],
        'quality_attributes': [],
        'constraints': [],
        'dependencies': []
    }
    
    for req in requirements_data['requirements']:
        category = classify_requirement(req)
        complexity = assess_complexity(req)
        categorized_reqs[category].append({
            'requirement': req,
            'complexity': complexity,
            'related_goals': find_related_goals(req, goals_data)
        })
    
    return categorized_reqs
```

### 2. Task Generation Strategies

#### Functional Decomposition
- Break down functional requirements into implementation tasks
- Identify data, logic, and interface components
- Create tasks for unit development, integration, and testing

#### Feature-Based Breakdown  
- Group related requirements into features
- Create epics for complex features
- Decompose epics into user stories and technical tasks

#### Technology Stack Tasks
- Infrastructure setup and configuration
- Framework and library integration
- Database schema and migration tasks
- API design and implementation

### 3. Acceptance Criteria Generation

```python
def generate_acceptance_criteria(requirement, context):
    """
    Create testable acceptance criteria from requirements
    """
    criteria = []
    
    # Extract measurable outcomes
    outcomes = extract_measurable_outcomes(requirement)
    
    # Create behavior specifications
    for outcome in outcomes:
        criteria.append({
            'criterion': format_as_given_when_then(outcome),
            'testable': True,
            'definition_of_done': generate_dod(outcome)
        })
    
    # Add non-functional criteria
    criteria.extend(generate_nfr_criteria(requirement, context))
    
    return criteria
```

### 4. Dependency Analysis

#### Sequential Dependencies
- Prerequisites that block task initiation
- Data dependencies between tasks  
- Technical architecture decisions

#### Parallel Opportunities
- Independent development streams
- Concurrent testing and development
- Documentation and development overlap

#### Critical Path Identification
- Longest dependent task sequence
- Resource bottlenecks
- Risk-adjusted timelines

### 5. Task Categorization Framework

| Category | Description | Examples |
|----------|-------------|----------|
| **Development** | Implementation of functional features | Code development, API creation |
| **Design** | User experience and system design | UI mockups, architecture design |
| **Testing** | Verification and validation activities | Unit tests, integration tests |
| **Documentation** | Knowledge capture and communication | User guides, technical docs |
| **Integration** | System connectivity and data flow | API integration, data migration |
| **Deployment** | Release and operational setup | CI/CD, environment setup |
| **Research** | Investigation and proof of concepts | Technology evaluation, spikes |

### 6. Effort Estimation

```python
def estimate_task_effort(task, historical_data=None):
    """
    Estimate effort using multiple techniques
    """
    estimates = []
    
    # Story point mapping to hours/days
    story_points = assess_story_points(task)
    estimates.append(story_points * velocity_factor)
    
    # Analogous estimation from similar tasks
    if historical_data:
        similar_tasks = find_similar_tasks(task, historical_data)
        estimates.append(calculate_analogous_estimate(similar_tasks))
    
    # Three-point estimation (optimistic, likely, pessimistic)
    optimistic, likely, pessimistic = get_three_point_estimates(task)
    pert_estimate = (optimistic + 4*likely + pessimistic) / 6
    estimates.append(pert_estimate)
    
    # Return weighted average with confidence interval
    return {
        'estimate': weighted_average(estimates),
        'confidence_low': min(estimates),
        'confidence_high': max(estimates)
    }
```

## Integration Workflow

### 1. Input Processing
- Load requirements.json and goals.json data
- Parse W5H analysis for additional context
- Validate input data completeness and consistency

### 2. Task Generation Pipeline
```markdown
Requirements → Feature Groups → Tasks → Acceptance Criteria → Dependencies → Estimation
```

### 3. Output Generation
- Generate JSON structure for programmatic use
- Create human-readable markdown documentation  
- Populate individual task files in tasks/ directory
- Update project tracking structures

### 4. Quality Assurance
- Verify all requirements are covered by tasks
- Ensure task dependencies are acyclic
- Validate acceptance criteria are testable
- Check effort estimates are reasonable

## Usage Examples

### Example 1: Web Application Development

**Input Requirements:**
- R-001: User authentication system
- R-002: User profile management  
- R-003: Data visualization dashboard

**Generated Tasks:**
```
T001 - Setup Authentication Framework (development, high, 2.0 days)
T002 - Implement User Registration (development, high, 1.5 days)  
T003 - Design Profile Management UI (design, medium, 1.0 days)
T004 - Build Profile API Endpoints (development, medium, 1.5 days)
T005 - Create Data Visualization Components (development, high, 3.0 days)
T006 - Integration Testing Suite (testing, medium, 2.0 days)
```

**Dependency Chain:**
T001 → T002 → T004 → T006
T003 → T004
T005 → T006

### Example 2: Skill Development Project

**Input:** Building Skills project requirements

**Generated Phase Structure:**
```
Phase 1: Foundation (10 days)
- T001: Requirements ingestion skill
- T002: Goals extraction skill
- T003: W5H analysis skill

Phase 2: Domain Modeling (8 days)  
- T004: Domain concept extraction
- T005: Entity alignment
- T006: New concept proposal

Phase 3: Planning & Integration (12 days)
- T007: Task derivation skill (this task!)
- T008: Integration management
- T009: Change management system
```

## Error Handling

### Input Validation
- Missing or malformed requirements.json
- Inconsistent goal-requirement traceability  
- Circular dependency detection

### Recovery Strategies
- Generate placeholder tasks for incomplete requirements
- Flag unresolved dependencies for manual review
- Provide alternative task breakdowns for complex requirements

## Success Metrics

### Coverage Metrics
- **Requirement Coverage**: % of requirements mapped to tasks
- **Goal Traceability**: % of goals supported by task outcomes  
- **Acceptance Completeness**: % of tasks with testable criteria

### Quality Metrics  
- **Dependency Consistency**: No circular dependencies
- **Estimate Accuracy**: Variance from actual effort (when available)
- **Task Granularity**: Appropriate size for tracking and execution

### Process Metrics
- **Generation Time**: Skill execution performance
- **Manual Override Rate**: % of tasks requiring manual adjustment
- **Stakeholder Adoption**: Usage of generated task structures

## Customization Points

### Task Templates
- Modify task structure for specific project types
- Customize acceptance criteria patterns
- Adjust effort estimation parameters

### Categorization Rules
- Define domain-specific task categories
- Create custom dependency types
- Add project-specific quality gates

### Integration Hooks
- Connect with existing project management tools
- Export to Jira, Azure DevOps, or GitHub Issues
- Sync with calendar and resource planning systems

## Dependencies

### Required Skills
- **requirements-ingest**: Provides structured requirements input
- **goals-extract**: Provides goal context for task alignment
- **process-w5h**: Provides analytical context for task scope

### Optional Skills
- **process-scopemin**: Can provide scope prioritization for task ordering
- **domain-extractconcepts**: Domain context for technical task definition
- **project-planning-tracking**: Integration with broader project management

## Version History

- **v1.0**: Initial implementation with basic task generation
- **v1.1**: Added dependency analysis and critical path identification  
- **v1.2**: Enhanced acceptance criteria generation
- **v1.3**: Integrated effort estimation algorithms
- **v2.0**: Added phase-based breakdown and parallel execution analysis